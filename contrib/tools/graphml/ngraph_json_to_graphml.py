#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Simple converter to convert nGraph JSON format to GraphML.
#  
# Original Author: Vasanth Tovinkere
# Date: 2/5/2018
#
# Usage: python ngraph_json_to_graphml.py <file>.json > <file>.graphml
#
import json
import sys

def prepare_header(name):
    print('<?xml version="1.0" encoding="UTF-8"?>')
    print("<!-- Generated by ngraph converter 1.0 for FGA 1.17041-->")
    print('''<graphml xmlns="http://graphml.graphdrawing.org/xmlns"  
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
           http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd"
           name="{}" version ="1.17041">'''.format(name))
    print("   <key id=\"node_type\" attr.name=\"node_type\" attr.type=\"string\" for=\"node\" namespace=\"all::node\"/>")
    print("   <key id=\"plugin\" attr.name=\"plugin\" attr.type=\"string\" for=\"node\" namespace=\"all::node\"/>")
    print("   <key id=\"object_name\" attr.name=\"object_name\" attr.type=\"string\" for=\"node\" namespace=\"all::node\"/>")
    print("   <key id=\"description\" attr.name=\"description\" attr.type=\"string\" for=\"node\" namespace=\"all::node\"/>")

def output_close_graph(indent):
    indentation = " "
    i = 1
    while (i < indent):
        indentation += " "
        i = i + 1
    print("{}</graph>".format(indentation))

def output_open_graph(indent, graph_name):
    indentation = " "
    i = 1
    while (i < indent):
        indentation += " "
        i = i + 1
    print("{}<graph id=\"{}\" edgedefault=\"directed\">".format(indentation, graph_name))

def output_required_properties(indent, name, operation, data_type, description):
    indentation = " "
    i = 1
    while (i < indent):
        indentation += " "
        i = i + 1
    print("{}<data key=\"node_type\">{}</data>".format(indentation, operation))
    print("{}<data key=\"plugin\">ngraph</data>".format(indentation))
    print("{}<data key=\"object_name\">{}</data>".format(indentation, name))
    print("{}<data key=\"data_type\">{}</data>".format(indentation, data_type))
    print("{}<data key=\"description\">{}</data>".format(indentation, description))

def output_ports(indent, ip_count, op_count, data_type):
    indentation = " "
    i = 1
    while (i < indent):
        indentation += " "
        i = i + 1
    if(ip_count):
        print("{}<port data_type=\"{}\" name=\"in_port_0\" offset=\"0\" type=\"input\"/>".format(indentation, data_type))
    if(op_count):
        print("{}<port data_type=\"{}\" name=\"out_port_0\" offset=\"0\" type=\"output\"/>".format(indentation, data_type))

  
def close_node(indent):
    indentation = " "
    i = 1
    while (i < indent):
        indentation += " "
        i = i + 1
    print("{}</node>".format(indentation))

def output_node(indent, name, operation, description, has_inputs, inputs, has_outputs, outputs, data_type):
    indentation = " "
    i = 1
    while (i < indent):
        indentation += " "
        i = i + 1
    print("{}<node id=\"{}\">".format(indentation, name))
    indent += 3
    output_required_properties(indent, name, operation, data_type, description)
    output_ports(indent, has_inputs, has_outputs, data_type)
    indent -=3
    close_node(indent)

def output_edge(indent, edge_id, from_node, to_node):
    indentation = " "
    i = 1
    while (i < indent):
        indentation += " "
        i = i + 1
    edge_id = "e" + format(edge_id)
    print("{}<edge id=\"{}\" source=\"{}\" sourceoffset=\"0\" sourceport=\"out_port_0\" target=\"{}\" targetoffset=\"0\" targetport=\"in_port_0\" />".format(indentation, edge_id, from_node, to_node))

def main():
    #
    #  Load the JSON file into memory
    #

    file = sys.argv[1]
    with open(file, 'r') as f:
        data = json.load(f)
    #
    #  Extract the ngraph function name
    #
    ngraph_func_name  = data[0]['name']

    #
    #  Write the GraphML headers along with the
    #  required keys for each node
    #
    prepare_header(ngraph_func_name)
    #
    #  Go through all the grpah that exist in
    #  the JSON file and output them 
    #
    common_attrs = ['inputs', 'name', 'outputs', 'op', 'element_type']
    indent = 3
    for i, graph in enumerate(data):
        graph_name      = "graph_" + format(i)
        output_open_graph(indent, graph_name)

        parameters      = graph['parameters']
        result          = graph['result']
        operations_list = graph['ops']

        indent += 3
        #
        #  Go through each node and output it in 
        #  graphml format
        #
        for node in operations_list:
            inputs = node['inputs']
            has_inputs = len(inputs)
            name = node['name']
            outputs = node['outputs']
            has_outputs = len(outputs)
            operation = node['op']
            description = ""
            #
            #  Since we do not know what these are, let's
            #  group them under 'description'; we are 
            #  creating a multi-line description here
            #
            if 'element_type' in node['value_type']:
                data_type = node['value_type']['element_type']
            else:
                data_type = "unknown_element_type"

            # if 'shape' in node:
            #     description = "Shape (" + format(node['shape']) + ")"
            # if 'output_shape' in node:
            #     description = "Output Shape (" + format(node['output_shape']) + ")"
            # if 'output_shapes' in node:
            #     description = "Output Shapes (" + format(node['output_shapes']) + ")"
            # if 'lower_bounds' in node:
            #     description  = "Lower bounds: " + format(node['lower_bounds']) + "\n"
            #     description += "Stride: " + format(node['strides']) + "\n"
            #     description += "Upper bounds: " + format(node['upper_bounds']) + "\n"
            for attr in node:
                if attr not in common_attrs:
                    description += attr + ": " + format(node[attr]) + "\n"

            output_node(indent, name, operation, description, has_inputs, inputs, has_outputs, outputs, data_type)

        #
        #  We will go through all the nodes again, but this
        #  time, we are looking the inputs and outputs to
        #  create the edges. I am sure there are more efficient
        #  ways to do this in Python, but this is my first 
        #  Python script - so have mercy!
        #
        edge_id = 1
        for node in operations_list:
            inputs = node['inputs']
            has_inputs = len(inputs)
            name = node['name']
            outputs = node['outputs']
            has_outputs = len(outputs)
            for i in range(has_inputs):
                from_node = inputs[i]
                output_edge(indent, edge_id, from_node, name)
                edge_id = edge_id + 1

        indent -= 3
        output_close_graph(indent)
        print("</graphml>")

if __name__ == "__main__":
    main()